<?php
    //1.get different racks 2.generate different queries 3.use different queries to get words 4.formalize the words
    
    $myrack=$_REQUEST["myrack"];//b means the word which is generated by the system.
    $answer=$_REQUEST["answer"];
    
    $racks = [];
    for($i = 0; $i < pow(2, strlen($myrack)); $i++){ //there are 2^strlen($myrack) possible possibilities 
	    $ans = "";
	    for($j = 0; $j < strlen($myrack); $j++){
		    //if the jth digit of i is 1 then include letter
		    if (($i >> $j) % 2) { //shifting the digit in order to include all of the letters in these 2^strlen($myrack) possibilities 
		    $ans .= $myrack[$j];
		    }
	    }
	    if (strlen($ans) > 1){
  	        $racks[] = $ans;	
	    }
    }
    $racks = array_unique($racks);
    $rackslength=count($racks);
    for($x=0;$x<$rackslength;$x++){$rackarray[]=$racks[$x];}  //store the different combinations of $racks into $rackarray
    //foreach($rackarray as $value){echo $value.'<br/>';}
    
    
    
    //generate different queries: 
    //this is the basic way of getting a database handler from PDO, PHP's built in quasi-ORM
    $dbhandle = new PDO("sqlite:scrabble.sqlite") or die("Failed to open DB");
    if (!$dbhandle) die ($error);
 
    //this is a sample query which gets some data, the order by part shuffles the results
    //the limit 0, 10 takes the first 10 results.
    // you might want to consider taking more results, implementing "pagination", 
    // ordering by rank, etc.
    for($i=0;$i<$rackslength;$i++){
    $query[] = "SELECT words from racks where rack = "."\"".$rackarray[$i]."\""; //generate all the queries
    //echo "SELECT words from racks where rack = "."\"".$rackarray[$i]."\"";
    }
    
    $pieces=[];
    for($i=0;$i<$rackslength;$i++){
        $statement = $dbhandle->prepare($query[$i]);
        $statement->execute();
        $results = $statement->fetchAll(PDO::FETCH_ASSOC);
        if(strlen(json_encode($results) ) > 3){$wordsraw[]=json_encode($results);//{["words:""apple"],["words:""dog@@pip"],["words:""pl@@p"]}
                                                
                                                
                                                
                                                //echo json_encode($results);
            
        }

    
    }
    for($i=0;$i<count($wordsraw);$i++){$modifiedwordsraw[]=substr($wordsraw[$i],11,-3);
                                        $pieces=array_merge($pieces,explode("@@",$modifiedwordsraw[$i]));
    }
    //foreach($pieces as $value){echo $value.'<br/>';}
    $num=0;
    for($i=0;$i<count($pieces);$i++){
      
        if($pieces[$i]==$answer){
            
            echo "correct";
            $num++;
        }
        
    }
    
    if($num==0){echo "your answer is wrong";}
    
    
    
    
    
    //this next line could actually be used to provide user_given input to the query to 
    //avoid SQL injection attacks
    //$statement = $dbhandle->prepare($query);
    //$statement->execute();
    
    //The results of the query are typically many rows of data
    //there are several ways of getting the data out, iterating row by row,
    //I chose to get associative arrays inside of a big array
    //this will naturally create a pleasant array of JSON data when I echo in a couple lines
    //$results = $statement->fetchAll(PDO::FETCH_ASSOC);
    
    //this part is perhaps overkill but I wanted to set the HTTP headers and status code
    //making to this line means everything was great with this request
    header('HTTP/1.1 200 OK');
    //this lets the browser know to expect json
    header('Content-Type: application/json');
    //this creates json and gives it back to the browser
    
    
    //$a=json_encode($results);//{"words":"apple@@dog"}
    //$wordsraw=substr($a,11,-3);//{apple@@dog}
    //$words=explode("@@",$wordsraw);//{"apple","dog"}
    //foreach($words as $value){echo $value;echo "\n";}
    
    
    //foreach($a as $rackvalue){echo $rackvalue;}


    
    
    
?>